# VPL
Vector Phasor Language

See the PDF

This language works in the novel principles concepts of Quantum Computing. 

Once a wise man said

"Most of the reserved words should end in -anuos- to be properly accepted in the academia" or it was for science fiction book or a movie quote, I don't recall any more. 

Also the same wise man said:

"You need to produce +100 Kg of  papers and have 10000+ friends on LinkedIn or OF to become a respectable PhD"

Anyway...

The language runs in a qTape which encodes the instructions in a set of vector space operators  it is originally written for a Qcularor in mind but this technology has not been developed yet, we don't expect that it will take a lot of time to be done it depends on  how much effort society keeps placing to have another mass extintion event. Dynanosaurs lasted 180 M years, not sure if we can do any better, anyway.... For now, it can run on any low tech computers where each core represents a Qbitus and this should suffice for now. The program is executed indefinitely until it is observed at that point it collapses so only one output is available, but since what happens in the Hilbert space remains in the Hilbert space no postmortem analysis is possible, Variables and states can't be cloned because of the non cloning theorem.

The qparser is a qASS or q-abstract-syntax-spiner  if you are not into the brevery thing. Which does not follow any data structure for now.

All wrong parsing results collapses so after several iterations the only remaining observations might still valid. The first compilation step is done by the vectorian parser which does strict checking while converting the instructions in a chain of vector phasorial operations for different vector spaces, this is known is type-vector-approach or TVA.
Heresy, like in the movie, if is not computable in the matrix the program is not valid.

The target architecture is meant to run in a  Ion-Trapped-conisphierium that should be a shaped really pointy cone to be taken seriously by manufacturers, and it should have a lot of mirrors to look expensive and get a lot of budget. Of course, It is not invented yet and despite current limitations we can simulate it using a low tech processors. But the intuition of the qASS should suffice and motivate its internal design and production, because humans like to build pointy things but also shiny things. 

At the end who says we need, ALUS, Registries, Buses, memory when you could execute billions of random sets per second in the spin of electrons. Who says that the only way to communicate information inside hardware is using wires, hee, eee, Eeeee! 

A deterministic machine could be also designed using the deterministic version of the Quantum theory but since humans like to play with dices we stick with the quantum - phasorial - vectorian approach.

The first step of design is to transform all this written gibish bullshit from above into symbols defined carefully and proven by axioms and theorems. Later, disprove it, and correct it and disprove it again until it holds true, or partially true, or makes no sense anymore and just give up... Or we break the math and we need a more powerful math...  Discovering something or giving up is a wonderful game in life.  As math is incomplete, physics should be incomplete too and  this journey is totally incomplete, so maybe better to give up now. Still there are no excuses to avoid the use of symbols and do the proofing carefully, like one wise man said; "If you don't use symbols it is just bullshit" 

The end goals:

- Ion-Trapped-conisphierium (TBD)
- Vectorian Phasor language VPL (Under Work)
-Fabrications (TBD) We are not sure why we need this, something with a machine setup

-Oraculization (TBD) Not sure what it will do, something with an Oracle because that sounds important lately.

-Coinshufering (TBD) Something with probability, idk, toss coins...
 
VPL:

A vector is defined by a direction and magnitude, and if starts spinning is a phasor. You know what else spins...  electrons, wheels, motors, the planet earth, and maybe the universe a bit surely no one knows. 

Rules:

-All assignments are vectors 
-All operators do vector operations
-All math operations results are vectors 

-Data types are vectors too but in different spaces, as the vector space will be divided by types. Type casting is defined by a travel to a different Vectorial space.

- All loops are phasors because both go in circles 

- All decision statements are phasors too because everything could be done with a "While" (Where is my programming analysis book). 90 degrees means true and -90 means false, like when looking into the sky or into the ground. 

- All numbers are the magnitudes of the vector
